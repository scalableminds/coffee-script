// Generated by CoffeeScript 1.6.1
(function() {
  var Arr, Assign, Block, Call, Code, Comment, DefineRewriter, Literal, MacroRewriter, Param, Value, util, _ref,
    __slice = [].slice;

  _ref = require("./nodes"), Block = _ref.Block, Comment = _ref.Comment, Literal = _ref.Literal, Param = _ref.Param, Code = _ref.Code, Arr = _ref.Arr, Value = _ref.Value, Call = _ref.Call, Assign = _ref.Assign;

  util = require("util");

  DefineRewriter = (function() {

    function DefineRewriter() {}

    DefineRewriter.prototype.process = function(mainNode) {
      var defineBlock, node;
      defineBlock = null;
      mainNode.eachChild(function(node) {
        var match, matches, pair, _i, _len, _results;
        if (node.constructor === Comment && /^\s*define/gm.test(node.comment)) {
          defineBlock = {
            sources: [],
            targets: [],
            node: node
          };
          if (matches = node.comment.match(/\s*([^\"\n\s\:]+)\s*:\s*([^\"\n\s\:]+)\s*/gm)) {
            _results = [];
            for (_i = 0, _len = matches.length; _i < _len; _i++) {
              match = matches[_i];
              if (pair = match.match(/\s*([^\"\n\s\:]+)\s*:\s*([^\"\n\s\:]+)\s*/m)) {
                defineBlock.sources.push(pair[1]);
                _results.push(defineBlock.targets.push(pair[2]));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        }
      });
      if (defineBlock) {
        if (mainNode.expressions.indexOf(defineBlock.node) >= 0) {
          mainNode.expressions = (function() {
            var _i, _len, _ref1, _results;
            _ref1 = mainNode.expressions;
            _results = [];
            for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
              node = _ref1[_i];
              if (node !== defineBlock.node) {
                _results.push(node);
              }
            }
            return _results;
          })();
        }
        mainNode = new Block([
          new Call(new Value(new Literal("define")), [
            new Arr(defineBlock.sources.map(function(a) {
              return new Value(new Literal("\"" + a + "\""));
            })), new Code(defineBlock.targets.map(function(a) {
              return new Param(new Literal(a));
            }), mainNode)
          ])
        ]);
      }
      return mainNode;
    };

    return DefineRewriter;

  })();

  MacroRewriter = (function() {

    function MacroRewriter() {}

    MacroRewriter.prototype.process = function(mainNode) {
      var macros,
        _this = this;
      macros = {};
      mainNode.traverseChildren(true, function(node) {
        if (node.constructor === Assign && node.value.constructor === Code && /Macro$/.test(node.variable.base.value)) {
          return macros[node.variable.base.value] = node;
        }
      });
      this.replacingWalker(mainNode, function(node, replacer) {
        console.log(util.inspect(node));
        if (node.constructor === Call && macros[node.variable.base.value]) {
          return replacer(_this.macroTransformer(macros[node.variable.base.value], node));
        }
      });
      return mainNode;
    };

    MacroRewriter.prototype.replacingWalker = function(node, func) {
      var childName, childNode, childNodes, i, j, more, newNodes, _i, _j, _len, _ref1, _ref2;
      _ref1 = node.children;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        childName = _ref1[_i];
        childNode = node[childName];
        if (childNode instanceof Array) {
          childNodes = childNode;
          newNodes = [];
          i = 0;
          while (i < childNodes.length) {
            more = 0;
            func(childNodes[i], function(newNode) {
              if (childNode instanceof Array) {
                childNodes.splice.apply(childNodes, [i, 1].concat(__slice.call(newNode)));
                return more = newNode.length;
              } else {
                return childNodes[i] = newNode;
              }
            });
            for (j = _j = i, _ref2 = i + more; i <= _ref2 ? _j <= _ref2 : _j >= _ref2; j = i <= _ref2 ? ++_j : --_j) {
              this.replacingWalker(childNodes[j], func);
            }
            i += more + 1;
          }
        } else {
          func(childNode, function(newNode) {
            return node[childName] = newNode;
          });
          this.replacingWalker(childNode, func);
        }
        return;
      }
    };

    MacroRewriter.prototype.deepCloner = function(node) {
      var childName, childNode, childNodes, newNode, prop, _i, _j, _len, _len1, _ref1;
      newNode = {};
      for (prop in node) {
        newNode[prop] = node[prop];
      }
      newNode.constructor = node.constructor;
      newNode.__proto__ = node.__proto__;
      _ref1 = node.children;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        childName = _ref1[_i];
        childNode = node[childName];
        if (childNode instanceof Array) {
          childNodes = childNode;
          newNode[childName] = [];
          for (_j = 0, _len1 = childNodes.length; _j < _len1; _j++) {
            childNode = childNodes[_j];
            newNode[childName].push(this.deepCloner(childNode));
          }
        } else {
          node[childName] = this.deepCloner(childNode);
        }
      }
      return newNode;
    };

    MacroRewriter.prototype.macroTransformer = function(macroNode, callNode) {
      var callArgs, changedVariables, i, macroArgs, paramsMapping, _i, _ref1;
      macroNode = this.deepCloner(macroNode);
      macroArgs = macroNode.value.params.map(function(a) {
        return a.name.value;
      });
      callArgs = callNode.args.map(function(a) {
        return a.base.value;
      });
      paramsMapping = {};
      changedVariables = {};
      for (i = _i = 0, _ref1 = macroArgs.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        paramsMapping[macroArgs[i]] = callArgs[i];
      }
      macroNode.traverseChildren(true, function(node) {
        var newValue;
        if (node.constructor === Literal) {
          if (macroArgs.indexOf(node.value) >= 0) {
            return node.value = paramsMapping[node.value];
          } else if ((newValue = changedVariables[node.value])) {
            return node.value = newValue;
          }
        }
      });
      return macroNode.value.body.expressions;
    };

    return MacroRewriter;

  })();

  module.exports = function(mainNode) {
    return new DefineRewriter().process(mainNode);
  };

}).call(this);
